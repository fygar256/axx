---
title: 一般アセンブラ General Assembler 'axx'
tags: Terminal Python general assembler
author: fygar256
slide: false
---
GENERAL ASSEMBLER 'axx.py'

pythonで書いたので、ニックネームはPaxxです。

# 動作試験環境

Arch linux terminal

# 本文

axx.pyはアセンブラを一般化したジェネラル（一般）アセンブラです。

実行プラットフォームも特定の処理系に依存しません。DOSファイルの行末のchr(13)も無視するようにしています。pythonが動く処理系だったら動作すると思います。

axxは、パターンデータを用意すれば、任意のプロセッサアーキテクチャを処理できますが、専用のアセンブラの備えている実用的な機能はサポートしていません。今のヴァージョンは試験的実装です。実用的な機能について、マクロはプリプロセッサを使ってください。とりあえず、リンカ・ローダは、バイナリファイルとラベル（シンボル）ファイルを加工するプログラムを使ってください。

パターンファイルとソースファイルが分離されているため、コード化の手間を考えなければ、あるインストラクションセットのソースから別のプロセッサの機械語を生成することも可能です。

パターンデータは、制御構文を代入以外は持ちません。アセンブリ言語に限らず、バイナリ生成に使えます。

アセンブリ言語はプロセッサのインストラクションと1対1に対応しているので、axxが実現しました。

#### 使い方

`python axx.py patternfile.axx [sample.s] [-o outfile.bin] [-e expfile.tsv] [-i impfile.tsv]`のように使います。

axxは第1引数から、アセンブラのパターンデータを読み込み、パターンデータに基づき第2引数のソースファイルをアセンブルします。第2引数を省略したら、端末（標準入力）からソースを入力します。

結果は、標準出力にテキストとして出力され、`-o`オプションで指定された引数があれば、カレントディレクトリにバイナリファイルが出力されます。`-e`オプションは、`.export`で指定されたラベルをTSV形式でファイルに出力します。

axxでは、アセンブリ言語ソースファイルや標準入力から入力するラインをアセンブリラインと名付けます。

## パターンファイルの解説

パターンファイルは、個々のプロセッサに対応するため、ユーザー定義です。

パターンファイルの中のパターンデータは次のように並んでいます。

```
instruction  :: error_patterns  :: binary_list 
instruction  :: error_patterns  :: binary_list 
instruction  :: error_patterns  :: binary_list 
:
:
```

instructionは省略不可です。error_patternsは省略可です。binary_listは省略不可です。
instruction、error_patterns、binary_listは、`::`で区切ってください。

for ex. (x86_64)

```
RET　:: 0xc3
```

パターンデータの種類は次の2種類になります。

```
(1) instruction     ::                          binary_list
(2) instruction     ::       error_patterns  :: binary_list
```

#### コメント

パターンファイル内に、`/*`を書くとその行の`/*`以降がコメントになります。今の所、`*/`で閉じることはできません。その行の`/*`以降だけに有効です。

#### 大文字・小文字の区別、変数

パターンファイルのinstructionの大文字は文字定数として扱われます。小文字にすると、１文字の変数として扱われます。アセンブルラインから、instructionのその位置に当たる式やfactorやシンボルの値が変数に代入され、error_patternsとbinary_listから参照されます。

小文字のaからgは式、hからnはfactor、oからzはシンボルを表します。代入されてない変数は全て初期値の0です。

アセンブリラインからは、ラベルやセクション名以外は、大文字でも小文字も同じとして受け付けます。

特殊な変数は'$$'で、現在のロケーションカウンタを表します。


#### エスケープキャラクタ

instruction内でエスケープキャラクタ`\`が使えます。

#### error_patterns

error_patternsは、変数と比較演算子を使い、エラーの出る条件を指定します。

エラーパターンは複数指定可で、','で区切って記述します。例えば、次のようです。

```
a>3;4,b>7;5
```
この例では、a>3のとき、エラーコード4を返し、b>7のときエラーコード5を返します。

#### binary_list

binary_listは、出力するコードを','で区切って指定します。例えば、0x03,dとすると、0x3の次にdが出力されます。

8048を例に取ります。パターンファイルに

```
ADD    A,Rn ::  n>7;5 :: n|0x68
```

があるとし、アセンブリラインに`add a,rn`を渡すと、n>7のときエラーコード5を返し、`add a,r1`で、0x69のバイナリが生成されます

binary_listの要素が空だと、アライメントをします。冒頭から、`,`で始まったり、`0x12,,0x13`などとすると、空の部分が丁度のアドレスまでパディングされます。

binary_listの要素の先頭に`;`がつくと、その要素が0だった場合、出力されません。

#### symbol

```
.setsym :: symbol :: n
```

と書くと、symbolが値nで定義されます。

シンボルは、アルファベット、数字、いくつかの記号列です。

symbol1でsymbol2を定義するのは以下のように書きます。

```
.setsym ::symbol1 ::1
.setsym ::symbol2 ::#symbol1
```

symbol定義のz80の例を挙げます。パターンファイル内に

```
.setsym ::B ::0
.setsym ::C ::1
.setsym ::D ::2
.setsym ::E ::3
.setsym ::H ::4
.setsym ::L ::5
.setsym ::A ::7
.setsym ::BC ::0x00
.setsym ::DE ::0x10
.setsym ::HL ::0x20
.setsym ::SP ::0x30
```

と書いておくと、シンボルB,C,D,E,H,L,A,BC,DE,HL,SPを、それぞれ0,1,2,3,4,5,7,0x00,0x10,0x20,0x30として定義します。シンボルには、大文字小文字の区別はありません。

パターンファイル中に同じシンボルの定義が複数あると、新しいものが古いものを更新します。すなわち、

```
.setsym ::B::0
.setsym ::C::1
ADD A,s

.setsym ::NZ::0
.setsym ::Z::1
.setsym ::NC::2
.setsym ::C ::3
RET s
```
この場合、ADD A,CのCは１、RET CのCは3になります。

・記号、数字、アルファベットが混在するシンボルの例

```
.setsym ::$s5:: 21
```

シンボルのクリアは`.clearsym`でします。

```
.clearsym::ax
```

上の例は`ax`というシンボルを未定義にします。

全クリアは引数を指定しないでします。

```
.clearsym
```

パターンファイル内から、シンボルに使う文字セットを決めることができます。

```
.symbolc::<characters>
```

とすると、数字とアルファベット大文字小文字以外の文字を`<characters>`で指定できます。

デフォルトは、アルファベット＋数字＋`'_%$-~&|'`です。

#### パターンの順番

パターンファイルは上から順に評価されますので、先に置かれたほうが優先します。特殊のパターンを先に、一般のパターンを後に置きます。下のように。

```
LD A,(HL)
LD A,e
```

#### 二重大括弧

instructionの中の省略可能なものは二重大括弧で括れます。z80の`inc (ix)`命令を示します。

```
INC	(IX[[+d]]) ::				    0xdd,0x34,d
```

この場合、小文字の変数の初期値は0なので、`inc (ix+0x12)`と、省略しなかった場合は`0xdd,0x34,0x12`が、`inc (ix)`と、省略した場合は`0xdd,0x34,0x00`が出力されます。

#### パディングのバイトコード指定

パターンファイルから、

```
.padding 0x12
```

と、するとパディングするバイトコードは0x12になります。デフォルトは0x00です。

#### include

このようにするとファイルをインクルードできます。

```
.include "file.axx"
```

## アセンブリファイルの解説

#### label

アセンブルラインからは、ラベルは以下の方法で定義することができます。

```
label1:
label2: .equ 0x10
label3: nop
```

ラベルは、数字以外の`.`かアルファベットかいくつかの記号から始まる、２文字以上の、アルファベットと数字といくつかの記号列です。

ラベルでラベルを定義することは以下のようにします。

```
label4: .equ label1
```

パターンファイル内から、ラベルに使う文字セットを決めることができます。

```
.labelc::<characters>
```

とすると、数字とアルファベット大文字小文字以外の文字を`<characters>`で指定できます。

デフォルトは、アルファベット＋数字＋アンダースコアです。ラベルの先頭のみ`.`が許されます。

ラベル参照のあとに`:`をつけると、未定義ラベルエラーのチェックをします。`:`を使うアセンブリ言語では、label参照のあとにスペースを入れてください。

#### ORG

ORGは、アセンブルラインから、

```
.org 0x800
```
とします。

#### アライメント

アセンブルラインから、

```
.align 16
```

とすると、16でアライメントします（16の倍数アドレスまで.paddingで指定されたバイトコードでパディングします)。引数を省略すると、直前の.alignで指定した数値あるいはデフォルト値でアライメントをします。

#### 浮動小数点、数の表記

例えば、浮動小数点をオペランドに含むプロセッサがあるとし、 `MOVF fa,3.14` で、faレジスタに3.14がロードされ、そのオペコードは01とします。その場合、パターンデータは、

```
MOVF FA,d ::0x01,d>>24,d>>16,d>>8,d
```

となり、アセンブルラインに、`movf fa,0f3.14`を渡すと、バイナリ出力は、0x01,0xc3,0xf5,0x48,0x40と なります。

2進数は'0b'のプリフィックスを付けて下さい。

16進数は'0x'のプリフィックスを付けて下さい。

浮動小数点float(32bit)は'0f'のプリフィックスを付けて下さい。

浮動小数点double(float 64bit)は、'0d'のプリフィックスを付けて下さい。

#### 文字列

`.ascii`で、文字列の、`.asciiz`で、末尾に0x00を伴う文字列のバイトコードを出力します。

```
.ascii "sample1"
.asciiz "sample2"
```

#### export

下のようにすると、labelをexportできます。.export命令で指定されたlabelだけがexportされます。

```
.export label
```

#### section

下のようにすると、sectionを指定できます。

```
section .text
```

#### section sort

例えば、

```
section .text
ld a,9
section .data
.asciiz "test1"
section .text
ld b,9
section .data
db 0x12
```

などとすると、その通りに配置されてしまうので、section sortを使って、整列させてください。

https://qiita.com/fygar256/items/fd590cab2078a4e8b866

```
section .text
ld a,9
ld b,9
section .data
.asciiz "test1"
db 0x12
```

#### コメント

アセンブリラインのコメントは`;`です。

## 式、演算子

アセンブリラインの式も、パターンデータの式も、同じ関数を呼び出しているので、ほとんど同じです。アセンブリラインにはラベルが書けます。パターンデータには小文字変数が書けます。

#### 演算子の優先順位

演算子と優先順位はpythonを基にして次の通り

```
(expression)    括弧で囲った式
#               symbolの値を返す演算子
-,~             負、ビットNOT
@               後に続く値の最高位ビットが右から何ビット目にあるかを返す単項演算子
:=              代入演算子
**              べき乗
*,//　　　　　    乗算、整数除算
+,-             加算、減算
<<,>>           左シフト、右シフト
&               ビットAND
|               ビットOR
^               ビットXOR
'               符号拡張
<=,<,>,>=,!=,== 比較演算子
not(x)          論理NOT
&&              論理AND
||              論理OR
```

代入オペレータとして`:=`があります。`d:=24`とすると、変数dに24が代入されます。代入オペレータが持つ値は、代入された値です。

前置オペレータ`#`は、後に続くシンボルの値を取ります。

前置オペレータ`@`は、後に続く値の最高位ビットが、右から何番目にあるかを返します。これをHebimarumattaオペレータと名付けます。

2項演算子`'`は`a'24`とすると、aの24ビット目のビットを符号ビットにして符号拡張（Sign EXtend)します。これをSEXオペレータと名付けます。

2項演算子`**`は、べき乗です。


## バイナリ出力の例

```
.setsym:: BC:: 0x00
.setsym:: DE:: 0x10
.setsym:: HL:: 0x20
LD    s,d::  (s&0xf!=0)||(s>>4)>3;9 :: s|0x01,d&0xff,d>>8
```

で、`ld bc,0x1234, ld de,0x1234, ld hl,0x1234`が、それぞれ、`0x01,0x34,0x12、0x11,0x34,0x12、0x21,0x34,0x12`を出力します。

### いくつかのプロセッサのいくつかの命令のテスト

テストですので、バイナリは実際のコードとは違います。

```test.axx
/* test
.setsym ::a:: 7
.setsym ::b:: 1
.setsym ::%% ::7
.setsym ::||:: 8
LD s,x :: 0x1,y,s,x

/* ARM64
.setsym ::r1 :: 2
.setsym ::r2 :: 3
.setsym ::r3 :: 4
.setsym ::lsl:: 6
ADD w, x, y z #d :: 0x88,d
ADD x, y, e :: 0x91,x,y,e

/* A64FX
.setsym ::v0 :: 0
.setsym ::x0 :: 1
ST1 {x.4S},[y] :: 0x01,x,y,0

/* MIPS
.setsym ::$s5 ::21
.setsym ::$v0 ::2
.setsym ::$a0 ::4
ADDI x,y,d :: (e:=(0x20000000|(y<<21)|(x<<16)|d&0xffff))>>24,e>>16,e>>8,e

/* x86_64
.setsym ::rax:: 0
.setsym ::rbx:: 3
.setsym ::rcx ::1
.setsym ::rep ::0xf3

MMX A,B ::  ,0x12,0x13
LEAQ r,[s,t,d,e] :: 0x48,0x8d,0x04,((@d)-1)<<6|t<<3|s,e
LEAQ r, [ s + t * h + i ] :: 0x48,0x8d,0x04,((@h)-1)<<6|t<<3|s,i
[[z]] MOVSB :: ;z,0xa4
TEST :: 0x12,,0x13

/* ookakko test
LD (IX[[+d]]),(IX[[+e]]):: 0xfd,0x04,d,e 
NOP :: 0x01
```

```test.s
leaq rax , [ rbx , rcx , 2 , 0x40]
leaq rax , [ rbx + rcx * 2 + 0x40]
movsb
rep movsb
addi $v0,$a0,5
st1 {v0.4s},[x0]
add r1, r2, r3 lsl #20

```

実行例

```
$ axx.py test.axx test.s
0000000000000000: leaq rax , [ rbx , rcx , 2 , 0x40]  0x48 0x8d 0x04 0x4b 0x40
0000000000000005: leaq rax , [ rbx + rcx * 2 + 0x40]  0x48 0x8d 0x04 0x4b 0x40
000000000000000a: movsb  0xa4
000000000000000c: rep movsb  0xf3 0xa4
000000000000000e: addi $v0,$a0,5  0x20 0x82 0x00 0x05
0000000000000012: st1 {v0.4s},[x0]  0x01 0x00 0x01 0x00
0000000000000016: add r1, r2, r3 lsl #20  0x88 0x14
```

## error

labelが、パターンファイル内のシンボルと被るとエラーになります。
同じlabelを二度以上定義するとエラーになります。
構文解析ができないとエラーになります。
未定義ラベルを参照するとエラーになります

## コメント

・Sorry for original notation.

・無茶なこと言われましたが、量子コンピュータとLISPマシンには対応していません。
　量子コンピュータのアセンブリ言語は量子アセンブリと言われ、アセンブリ言語ではありません。
　LISPマシンのプログラムは、アセンブリ言語ではありません。

・ホームメイドプロセッサから、スーパーコンピュータまでどうぞ。にゃは。

・エミュレータを搭載しなければいけないような実行時に機械語のバイト帳が変化する命令には対応していません。

・Please evaluate and extend and fix this.


・マクロ機能はプリプロセッサを使ってください。

・リンカ・ローダは、オプション`-i`を指定したら、TSVファイルからラベルがインポートされ、オプション`-e`を指定したら、.exportで指定したlabelがTSVでファイルにエクスポートされるので、それを利用する。ラベルファイルのラベルの値は、バイナリファイル先頭からのオフセット値です。

・8ビット未満の、例えばビットスライスプロセッサや、機械語のワードがバイト単位でないプロセッサのアセンブルもできますが、axxは8ビット単位の出力です。そういうプロセッサは、オブジェクトファイルフォーマットに依存します。

・コアができたので、axxにパターンファイルを用意して、リンカと多機能マクロとIDEのラッパーをつけると立派なシステムになると思いますが、大層です。あとはgenericだから、誰か作ってください。実用化されると幸いです。

・パターンファイルをメタ言語にすると、可読性が高い、評価の順番に依存しなくなる、制御構文が書きやすい、プロセッサ定義ファイルのデバッグがやりやすい。やはりメタ言語の方がいい。

・axxを更に一般化して、メタ言語を使い、binary_listに文字列リテラルと文字列演算＋数値演算をもたせ、制御構文も持たせると、中間言語を生成したり、アセンブリ言語同士のコンバータができる。単純なコンパイラの記述もできる。その時、binary_listは、object_listに名前を変える。evalが使えるかな。それをするとなると、ドラスティックな書き換えが必要。メタ言語は、パターンデータから、複数行に亘る記述言語になる。実現可能である。axxを元にして誰か作るかもしれない。メタ言語をほぼ同じくして、一般Disassemblerもできそう。

## 今後の課題

・リンカに対応できるようにする。

・実用化させたい。僕はlinuxしか持ってないので、linuxで。linuxの特殊解は、ELFのオブジェクトファイルに対応して、ldでリンクできるようにする。

・パターンファイルの評価の順番が難しい。

・式の中のエスケープキャラクタが動かない。

### お願い

バグを見つけた方がいっしゃいましたら、どう動かないかお知らせ願えると幸いです。
